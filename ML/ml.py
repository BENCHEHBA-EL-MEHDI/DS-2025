# -*- coding: utf-8 -*-
"""ML.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NqjJMLxc3SloSOYmRl5AfjDyZfjSngVa
"""

pip install ucimlrepo

from ucimlrepo import fetch_ucirepo

# fetch dataset
national_health_and_nutrition_health_survey_2013_2014_nhanes_age_prediction_subset = fetch_ucirepo(id=887)

# data (as pandas dataframes)
X = national_health_and_nutrition_health_survey_2013_2014_nhanes_age_prediction_subset.data.features
y = national_health_and_nutrition_health_survey_2013_2014_nhanes_age_prediction_subset.data.targets

# metadata
print(national_health_and_nutrition_health_survey_2013_2014_nhanes_age_prediction_subset.metadata)

# variable information
print(national_health_and_nutrition_health_survey_2013_2014_nhanes_age_prediction_subset.variables)

import pandas as pd
import numpy as np

# Assuming X and y are already loaded from the ucimlrepo in a previous cell
# If this cell is run independently, X and y might not be defined.
# For the current notebook state, X and y are defined from cell R02k05YoncFi.

print("\n========= Features (X) Dataset summary ========= \n")
if 'X' in locals():
    X.info()
    print("\n========= Features (X) A few first samples ========= \n")
    print(X.head())
else:
    print("X dataframe not found. Please ensure it is loaded before running this cell.")

print("\n========= Targets (y) Dataset summary ========= \n")
if 'y' in locals():
    y.info()
    print("\n========= Targets (y) A few first samples ========= \n")
    print(y.head())
else:
    print("y dataframe not found. Please ensure it is loaded before running this cell.")

from sklearn.model_selection import train_test_split
Xa, Xt, Ya, Yt = train_test_split(X, y_transformed, shuffle=True, test_size=1/3,
stratify=y_transformed)
Xa, Xv, Ya, Yv = train_test_split(Xa, Ya, shuffle=True, test_size=0.5,
stratify=Ya)

from sklearn.neighbors import KNeighborsClassifier
# Fit the model on (Xa, Ya)
k = 3
clf = KNeighborsClassifier(n_neighbors = k)
clf.fit(Xa, Ya)
# Predict the labels of samples in Xv
Ypred_v = clf.predict(Xv)
# evaluate classification error rate
from sklearn.metrics import accuracy_score
error_v = 1-accuracy_score(Yv, Ypred_v)

# some hints
k_vector = np.arange(1, 37, 2) #define a vector of k=1, 3, 5, ...
error_train = np.empty(k_vector.shape)
error_val = np.empty(k_vector.shape)
for ind, k in enumerate(k_vector):
    #fit with k
    clf = KNeighborsClassifier(n_neighbors = k)
    clf.fit(Xa, Ya)
    # predict and evaluate on training and validation sets
    Ypred_train = clf.predict(Xa)
    error_train[ind] = 1 - accuracy_score(Ya, Ypred_train)
    Ypred_val = clf.predict(Xv)
    error_val[ind] = 1 - accuracy_score(Yv, Ypred_val)

# The original code was attempting to split a dataframe named 'df' into features and targets.
# However, the dataset has already been loaded into 'X' and 'y' dataframes in a previous cell.
# 'X' contains the features and 'y' contains the target variable 'age_group'.
# This cell will now display the value counts of the 'age_group' target variable.

print("\n========= Age Group Distribution ========= \n")
print(y['age_group'].value_counts())

# Convert the 'age_group' target variable into numerical labels for classification.
# Assuming 'Adult' maps to 0 and 'Senior' maps to 1 for binary classification.
y_transformed = y['age_group'].apply(lambda x: 1 if x == 'Senior' else 0)

print("\n========= Transformed Target (y_transformed) Distribution ========= \n")
print(y_transformed.value_counts())
print("\n========= Transformed Target (y_transformed) First few samples ========= \n")
print(y_transformed.head())

import matplotlib.pyplot as plt
import seaborn as sns
plt.figure()
ax = plt.gca()
sns.boxplot(data=X,orient="v",palette="Set1",width=1.5, notch=True)
ax.set_xticklabels(ax.get_xticklabels(),rotation=90)
plt.figure()
corr = X.corr()
sns.heatmap(corr)

import matplotlib.pyplot as plt
import seaborn as sns
plt.figure()
ax = plt.gca()
sns.boxplot(data=X,orient="v",palette="Set1",width=1.5, notch=True)
ax.set_xticklabels(ax.get_xticklabels(),rotation=90)
plt.show() # Ensure the boxplot is displayed

plt.figure()
corr = X.corr()
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt=".2f") # Added annot, cmap, and fmt for better visualization
plt.title('Correlation Matrix of Features') # Add a title for clarity
plt.show() # Display the heatmap