# -*- coding: utf-8 -*-
"""Analyse.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LE_LaPr0BW7oYRph2VVZCa3WIyIj7pal
"""

# Commented out IPython magic to ensure Python compatibility.
# Import necessary libraries and suppress warnings
import warnings
warnings.filterwarnings('ignore')

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib
matplotlib.use('Agg')  # Ensuring that matplotlib uses a non-interactive backend
import matplotlib.pyplot as plt
plt.switch_backend('Agg')  # Switch backend if needed

# Ensure inline plotting is enabled
# %matplotlib inline

# Set aesthetics for seaborn
sns.set(style='whitegrid', palette='muted', color_codes=True)

# Display version of libraries (optional)
print(f'pandas version: {pd.__version__}')
print(f'numpy version: {np.__version__}')
print(f'seaborn version: {sns.__version__}')
print(f'matplotlib version: {matplotlib.__version__}')

# Load the MyAnimeList dataset
df = pd.read_csv('/kaggle/input/myanimelist-2025/mal_anime.csv', encoding='utf-8')

# Display basic information about the dataframe
print('Shape of the dataset:', df.shape)
print('Columns in the dataset:', df.columns.tolist())

# Display first 5 rows for a quick preview
df.head()

# Let's take a closer look at the 'Episodes' and 'Premiered' columns
print('Unique values in Episodes column sample:', df['Episodes'].dropna().unique()[:10])
print('Unique values in Premiered column sample:', df['Premiered'].dropna().unique()[:10])

# Cleaning Episodes column: Attempt to convert to numeric; set non-numeric values to NaN
df['Episodes_clean'] = pd.to_numeric(df['Episodes'], errors='coerce')

# Handle any remaining missing values in Episodes_clean (if needed, you could fill with median or drop rows)
episodes_missing = df['Episodes_clean'].isnull().sum()
print('Missing numeric Episodes after conversion:', episodes_missing)

# Infer and parse date-like information from the 'Premiered' column if possible, example: 'Spring 2020'
# Here, we create a new column that extracts the year if present; this is a simple heuristic
def extract_year(premiered_str):
    try:
        # Attempt to extract a year from the string
        return int(premiered_str[-4:])
    except:
        return np.nan

df['Premiered_Year'] = df['Premiered'].dropna().apply(extract_year)
df['Premiered_Year'] = df['Premiered_Year'].combine_first(df['Released_Year'])

# Convert other potentially numeric columns that are read as strings
for col in ['Popularity', 'Members', 'Favorites']:
    df[col+'_num'] = pd.to_numeric(df[col], errors='coerce')

# Show a summary of the cleaned columns
print(df[['Episodes', 'Episodes_clean', 'Premiered', 'Premiered_Year', 'Popularity_num', 'Members_num', 'Favorites_num']].head())

# Sometimes others working with this data see errors converting mixed-type columns; using pd.to_numeric with errors='coerce' is a robust solution.

# Distribution of Score using a histogram
plt.figure(figsize=(10, 6))
sns.histplot(df['Score'], kde=True, bins=30, color='skyblue')
plt.title('Distribution of Anime Scores')
plt.xlabel('Score')
plt.ylabel('Frequency')
plt.tight_layout()
plt.show()

# Count plot for 'Type' column (Pie Chart style is typically done with plt.pie but here we use countplot for a bar visualization)
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='Type', palette='viridis')
plt.title('Count of Anime Types')
plt.xlabel('Type')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Box plot for the Score to check for outliers
plt.figure(figsize=(10, 6))
sns.boxplot(x=df['Score'], color='lightgreen')
plt.title('Box Plot of Anime Scores')
plt.xlabel('Score')
plt.tight_layout()
plt.show()

# Pair Plot: Using numeric columns only (if four or more, but here we have less so we can include a pair plot among a few columns)
numeric_df = df[['Episodes_clean', 'Premiered_Year', 'Popularity_num', 'Members_num', 'Favorites_num', 'Score']].dropna()
if numeric_df.shape[1] >= 2:
    sns.pairplot(numeric_df)
    plt.show()
else:
    print('Not enough numeric columns for a pair plot.')

# Optional: Heatmap for correlation if there are 4 or more numeric columns
if numeric_df.shape[1] >= 4:
    plt.figure(figsize=(10, 8))
    corr = numeric_df.corr()
    sns.heatmap(corr, annot=True, fmt='.2f', cmap='coolwarm')
    plt.title('Correlation Heatmap of Numeric Features')
    plt.tight_layout()
    plt.show()
else:
    print('Not enough numeric columns for a correlation heatmap.')

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score

# Select features for prediction
# We use Episodes_clean and Premiered_Year as predictors, ensure to drop rows with missing values
features = ['Episodes_clean', 'Premiered_Year']
target = 'Score'

model_data = df[features + [target]].dropna()

# Define X and y
X = model_data[features]
y = model_data[target]

# Train-test split to evaluate the predictor
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Build the linear regression model
lr_model = LinearRegression()
lr_model.fit(X_train, y_train)

# Predict on the test set
y_pred = lr_model.predict(X_test)

# Evaluate the model with Mean Squared Error and R2 Score
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print('Mean Squared Error:', mse)
print('R2 Score:', r2)

# Plot actual vs predicted
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred, alpha=0.6, color='coral')
plt.xlabel('Actual Score')
plt.ylabel('Predicted Score')
plt.title('Actual vs Predicted Anime Scores')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], color='blue', lw=2)
plt.tight_layout()
plt.show()